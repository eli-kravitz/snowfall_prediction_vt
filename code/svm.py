'''Make SVM classifier'''import numpy as npimport osimport pickleimport matplotlib.pyplot as pltfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplayfrom sklearn.decomposition import PCAfrom sklearn.model_selection import train_test_splitfrom sklearn.svm import SVCfrom sklearn.model_selection import GridSearchCVfrom sklearn.preprocessing import StandardScalerfrom mlxtend.plotting import plot_decision_regionsfrom imblearn.under_sampling import RandomUnderSampler# Location of data filepwd = os.getcwd()save_loc = os.path.join(pwd, 'nbc_data')    file_name = 'nbc_cat_data.pkl'full_file = os.path.join(save_loc, file_name)with open(full_file, 'rb') as input_file:    data_cat = pickle.load(input_file)# Randomly get rid of some of the data because this is really slooooowdata_cat = data_cat.sample(n=100000)# Get labelsy_str = np.array(data_cat['snowfall'])# Convert labels to binary (snow or no snow)y = np.ones(len(y_str), dtype=int)msk = y_str == '0'y[msk] = 0# Pop out snowfall columndata_cat = data_cat.drop(['snowfall'], axis=1)# Do PCA in order to make dataset visualizable and make things faster - # keep 90% explained variancepca = PCA()pca.fit(data_cat)# Get number of components with 90% variance explainedn_comp = pca.explained_variance_ratio_.cumsum()n_comp = n_comp > 0.9n_comp = [i for (i, x) in enumerate(n_comp) if x]n_comp = n_comp[0] + 1# Get principal componentspca = PCA(n_components=n_comp)pca.fit(data_cat)x = pca.transform(data_cat)# Save datasave_loc = os.path.join(pwd, 'svm_data')if not os.path.isdir(save_loc):    os.mkdir(save_loc)file_name = 'svm_data.pkl'full_file = os.path.join(save_loc, file_name)with open(full_file, 'wb') as handle:    pickle.dump([x, y], handle, protocol=pickle.HIGHEST_PROTOCOL)# Build SVM with principal componentsx_train, x_test, y_train, y_test = train_test_split(x, y,    test_size=0.3, random_state=42)# Scale datascaler = StandardScaler()x_train = scaler.fit_transform(x_train)x_test = scaler.fit_transform(x_test)# We need a balanced dataset - make equal labels with undersamplingunder_sampler = RandomUnderSampler(sampling_strategy='majority')x_train, y_train = under_sampler.fit_resample(x_train, y_train)# Save train and test datafile_name = 'svm_data_train.pkl'full_file = os.path.join(save_loc, file_name)with open(full_file, 'wb') as handle:    pickle.dump([x_train, y_train], handle, protocol=pickle.HIGHEST_PROTOCOL)    file_name = 'svm_data_test.pkl'full_file = os.path.join(save_loc, file_name)with open(full_file, 'wb') as handle:    pickle.dump([x_test, y_test], handle, protocol=pickle.HIGHEST_PROTOCOL)# Place to save figspwd = os.getcwd()save_loc = os.path.join(pwd, 'figs', 'svm')if not os.path.isdir(save_loc):    os.mkdir(save_loc)# Plot PCs colored by labelfig, ax = plt.subplots()ax.scatter(x_train[:, 0], x_train[:, 1], c=y_train, alpha=0.1)ax.set_xlabel('Principal Component 1')ax.set_ylabel('Principal Component 2')plt.grid()plt.title('Training Data Colored by Label')file_name = 'train_data.png'plt.savefig(os.path.join(save_loc, file_name), dpi=300, bbox_inches='tight')fig, ax = plt.subplots()ax.scatter(x_test[:, 0], x_test[:, 1], c=y_test, alpha=0.1)ax.set_xlabel('Principal Component 1')ax.set_ylabel('Principal Component 2')plt.grid()plt.title('Test Data Colored by Label')file_name = 'test_data.png'plt.savefig(os.path.join(save_loc, file_name), dpi=300, bbox_inches='tight')# Linear kernelparam_grid = {'C': [0.1, 1, 10, 100],              'kernel': ['linear']} grid = GridSearchCV(SVC(), param_grid, refit=True, verbose=3)grid.fit(x_train, y_train)best_params_lin = grid.best_params_model_lin = SVC(kernel='linear', random_state=1,                C=best_params_lin['C'])clf_lin = model_lin.fit(x_train, y_train)plt.figure()y_pred = clf_lin.predict(x_test)cm = confusion_matrix(y_test, y_pred)acc_lin = sum(cm.diagonal()) / cm.sum()ConfusionMatrixDisplay(cm).plot()file_name = 'lin_confusion.png'plt.savefig(os.path.join(save_loc, file_name), dpi=300, bbox_inches='tight')plt.figure()plot_decision_regions((x_train), (y_train), clf=clf_lin, legend=2)plt.xlabel('Principal Component 1')plt.ylabel('Principal Component 2')plt.title('Decision Boundary - Linear')file_name = 'lin_dec.png'plt.savefig(os.path.join(save_loc, file_name), dpi=300, bbox_inches='tight')# Polynomial kernelparam_grid = {'C': [0.1, 1, 10, 100],                'gamma': [1, 0.1, 0.01, 0.001, 0.0001],               'degree': [2, 3],              'kernel': ['poly']} grid = GridSearchCV(SVC(), param_grid, refit=True, verbose=3)grid.fit(x_train, y_train)best_params_poly = grid.best_params_model_poly = SVC(kernel='poly', random_state=1,                  C=best_params_poly['C'],                 degree=best_params_poly['degree'],                 gamma=best_params_poly['gamma'])clf_poly = model_poly.fit(x_train, y_train)plt.figure()y_pred = clf_poly.predict(x_test)cm = confusion_matrix(y_test, y_pred)acc_poly = sum(cm.diagonal()) / cm.sum()ConfusionMatrixDisplay(cm).plot()file_name = 'poly_confusion.png'plt.savefig(os.path.join(save_loc, file_name), dpi=300, bbox_inches='tight')plt.figure()plot_decision_regions((x_train), (y_train), clf=clf_poly, legend=2)plt.xlabel('Principal Component 1')plt.ylabel('Principal Component 2')plt.title('Decision Boundary - Polynomial')file_name = 'poly_dec.png'plt.savefig(os.path.join(save_loc, file_name), dpi=300, bbox_inches='tight')# RBF kernelparam_grid = {'C': [0.1, 1, 10, 100],                'gamma': [1, 0.1, 0.01, 0.001, 0.0001],               'kernel': ['rbf']} grid = GridSearchCV(SVC(), param_grid, refit=True, verbose=3)grid.fit(x_train, y_train)best_params_rbf = grid.best_params_model_rbf = SVC(kernel='rbf', random_state=1,                  C=best_params_rbf['C'],                 gamma=best_params_rbf['gamma'])clf_rbf = model_rbf.fit(x_train, y_train)plt.figure()y_pred = clf_rbf.predict(x_test)cm = confusion_matrix(y_test, y_pred)acc_rbf = sum(cm.diagonal()) / cm.sum()ConfusionMatrixDisplay(cm).plot()file_name = 'rbf_confusion.png'plt.savefig(os.path.join(save_loc, file_name), dpi=300, bbox_inches='tight')plt.figure()plot_decision_regions((x_train), (y_train), clf=clf_rbf, legend=2)plt.xlabel('Principal Component 1')plt.ylabel('Principal Component 2')plt.title('Decision Boundary - RBF')file_name = 'rbf_dec.png'plt.savefig(os.path.join(save_loc, file_name), dpi=300, bbox_inches='tight')